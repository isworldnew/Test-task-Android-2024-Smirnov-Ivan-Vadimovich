К решению этой задачи прилагаю нарисованную мной UML-диаграмму (scheme.png), описывающую иерархию.
Обозначения применил такие же, как в книге "Паттерны Проектирования" (Gang Of Four):

 - наклонный шрифт обозначает интерфейсы или абстрактные классы, а также методы, которые
   пока не имеют реализации
 - прямой шрифт обозначает обыкновенные классы (с полной реализацией), а также методы,
   для которых определена реализация
 - поля, get/set методы и всё то, что не имеет отношения к иерархии, диаграмма не
   включает, чтобы её не усложнять
 - те методы, которые обзавелись реализацией в родительском классе, ниже по иерархии не
   отмечаю, чтобы не перегружать блоки (до тех пор, пока эта реализация не будет
   переопределена)

Далее, думаю, код не нуждается в объяснении. За исключением проблемы квадрата и прямоугольника.
С точки зрения геометрии: квадрат - частный случай прямоугольника. Для квадарата нужно хранить
одно поле со значением длины, для прямоугольника - два. Тогда, с точки зрения наследования:
прямоугольник - наслденик квадрата.

Посмотрим на ситуацию с использованием полиморфизма.

Случай 1:
Rectangle a = new Square( ... );
//ситуация логичная и ожидаемая, среди
//прямоугольников могут быть и квадраты

Случай 2:
Square a = new Rectangle( ... );
//это даже выглядит смешно: по ссылке типа квадрат попадаться могут и прямоугольники

Понятно, что гораздо более разумно выглядит Случай 1, но и он не лишён проблем.
Так как у прямоугольника два поля, и они имеют геттеры и сеттеры - всё это благополучно
попадёт в класс-наследник - квадрат.
Даже если мы сделаем квадрату конструктор, который принимает только одно поле, ничто не
помешает конечному пользователю воспользоваться сеттером, и "испортить" квадрату равенство
сторон (по Square-ссылке запросто может оказаться объект с разными значениями длин). Тем более,
у нас не было требований на immutable для фигур - всё это может зависеть от бизнес-логики конкретной
задачи. Исправлять логику сеттерам квадрата (например, чтобы вызов одного из сеттеров ставил значение
новой длины обоим полям) - очень плохая идея, потому что мы делаем поведение кода совершенно неожиданным.

В результате, всё это наводит на мысль, что класс квадрата нам вовсе не нужен.

Для абстрактного класса RectangularBased, который будет описывать объёмные фигуры, базирующиеся
на прямоугольном основании, ввёл метод boolean baseIsSquare(), чтобы всегда иметь возможность
определить, лежит ли в основании фигуры квадрат. Этот метод, я считаю, будет полезен всем фигурам
на данной ветви наследования.
А вот для его наслденика - класса Parallelepiped, я добавил ещё и метод boolean isCube(), чтобы
иметь возможность среди параллелепипедов найти кубы. Этот метод имеет смысл только в данном классе.
Незачем было объвлять его (например, абстрактно) в RectangularBased, так как "тащить" его через
всех наследников, которые и близко не являются параллелепипедом (например, четырёхугольная пирамида)
- занятие достаточно странное.

Но я "оставил намёк" для конечного пользователя, сделав в Parallelepiped два конструктора, один
из которых принимает только одну величину, как бы предоставляя удобную возможность сразу создать куб.
