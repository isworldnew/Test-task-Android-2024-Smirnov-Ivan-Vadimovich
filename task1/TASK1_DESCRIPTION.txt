Из-за того, что трактовать условие задачи можно было по-разному, сделал два варианта решения.
"Определите дублированный элемент в массиве, в котором содержатся элементы типа int от 1 до 100,
при условии, что в массиве дублируется только один элемент"

Можно понимать это как "массив произвольной длины, но значения элементов в котором только [1, 100]
с возможностью дублирования лишь одного элемента".
А можно понимать, как "массив длиной 100 для элементов [1, 100], среди которых встречается один дубль"

Также, подразумеваю, что элементы могут быть перемешаны.


Основное (DuplicateDetector):
Самая обыкновенная Сортировка Подсчётом (Counting Sort) - на случай, когда длина массива не постоянна
(*ну понятно, что больше 101 длина не станет), а [1, 100] - лишь ограничение на величину элементов

Второстепенное (усовершенствованное - DuplicateDetectorOptimized):

Если условие задачи столь конкретно, имеет смысл найти интересные зависимости, чтобы оптимизировать алгоритм.
Сумма чисел [1, 100] = 5050.
Сумма чётных и нечётных элементов отрезка соответственно равна 2550 и 2500.

Если предположить, что число нечётное заменилось на дубль какого-то чётного числа,
тогда сумма нечётных уменьшится, а сумма чётных - увеличится.
И наоборот.

Это очень показательный признак. И вероятность того, что произойдёт дубль такого вида = 50%.

Иными словами: с вероятностью в 50% мы за один проход по массиву сможем найти дубль. Без выделения
дополнительной памяти и без сортировок.

В случае же, когда число заменяется дублем числа из той же группы делимости - мы сможем только определить
по изменению суммы, в какой группе появился дубль - в чётной или нечётной (сумма, где дубля нет, останется
прежней).

В таком случае также прибегаем к Сортировке Подсчётом. Вот, только, памяти выделяем ровно на 50 элементов,
и подсчитываем уже только чётные или нечётные элементы.

Конечно, мы не в C++, чтобы рассуждать о выделении памяти, но многие библиотечные алгоритмы в Java также
сильно оптимизированы для разных случаев.

Дабы не смущать пользователей кода отдельно лежащим enum-ом, сделал его внутренним приватным классом. Там
определены методы для выявления (не)чётных элементов, а также зависимость значения и индекса (для "половинчатой"
Сортировки Подсчётом). Мне кажется, с помощью enum-а код алгоритма больше ушёл в сторону ООП от процедурного стиля,
стал более читаемым.