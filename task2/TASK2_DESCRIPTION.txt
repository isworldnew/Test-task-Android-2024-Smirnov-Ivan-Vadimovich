Может показаться, что Сортировка Подсчётом уместна и в этом решении. Однако здесь у нас нет
ограничений по диапазону значений. Минимальное и максимальное значение типа int - очень велики.
Таким образом, массив для подсчёта элементов может совершенно нецелесообразно увеличиться до
огромных размеров. Особенно это будет заметно, если исходный массив малых размеров содержит
большие значения, близкие к границам типа int.

Я исхожу из того, что у меня в распоряжении нет оптимизированных библиотечных алгоритмов,
которые используют наиболее оптимальные методы сортировки для конкретного массива. А также
я предполгаю, что у меня нет заготовленных высокоуровневых структур данных.

Можно было сделать аналог HashMap, и в одном элементе хранить не один конкретный индекс, а диапазон
индексов. Или можно было бы прибегнуть к Quick Sort. Первая идея потребовала бы алгоритма
деления на диапазоны и распределения всех элементов по ним. И совсем не факт, что в результате
получился бы оптимальный алгоритм. Вторую идею я посчитал слишком уж процедурной.

Я вспомнил про такую структуру данных, как Бинарное Дерево Поиска. Это решение, как мне кажется, в
достаточной степени элегантное - алгоритм хоть и рекурсивный, но читается легко. К тому же, реализация
такой структуры данных удобно пишется с помощью ООП. Да, объекты узлов потребуют больше памяти, но
итоговое удобство структуры данных это компенсирует.

Сложность добавления узла в среднем O(log n), а в худшем случае O(n).
Обход дерева в глубину, когда каждый узел посещяется ровно 1 раз, тоже O(n) в худшем случае.

Данное дерево не самобалансирующееся. Оно может превратиться в связный список. Однако сложность
всё ещё приемлимая.

В решении исполльзовал inner class Node. Это значит, что объект Node не может быть создан отдельно
от объекта внешнего класса - BinarySearchTree. Это уместное решение, чтобы у пользователя кода не
было необходимости разбираться в работе двух классов.







